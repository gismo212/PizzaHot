Порт - это абстракция операционной системы, или абстракция протокола.

1. Resolve domain if not an IP (DNS query)
2. Open port 80 by default if not SSL and not overridden by a colon (http: //host:port/)
3. Send request (#1) for http: //host/uri/here?other=stuff&too
4. Receive response (#2)
5. Close
Порты:

80 - http
443 - https




браузер получает запрос от пользователя и url преобразует в ip адрес
Запрос:

GET /uri/here?other=stuff&too HTTP/1.1
Host: host
Other: Headers, too.  Such as cookies
Header: Value
Ответ:

HTTP/1.1 200 OK
Other: Headers, too.  Such as cookies
Header: Value

<html>Actual HTTP payload is here, could be HTML data, downloaded file data, etc.


what happens when you type in a URL in browser
1. browser checks cache; if requested object is in cache and is fresh, skip to #9
2. browser asks OS for server's IP address
3. OS makes a DNS lookup and replies the IP address to the browser
4. browser opens a TCP connection to server (this step is much more complex with HTTPS)
5. browser sends the HTTP request through TCP connection
6. browser receives HTTP response and may close the TCP connection, or reuse it for another request
7. browser checks if the response is a redirect or a conditional response (3xx result status codes), authorization request (401), error (4xx and 5xx), etc.; these are handled differently from normal responses (2xx)
8. if cacheable, response is stored in cache
9. browser decodes response (e.g. if it's gzipped)
10. browser determines what to do with response (e.g. is it a HTML page, is it an image, is it a sound clip?)
11. browser renders response, or offers a download dialog for unrecognized types




В JS функция вызывается по хэндлеру/событию (обработчик):

<button onclick="foo()">Click me!</button>

что писать js функцию в html коде указываем тег script
<script>
  function foo() {
    alert("Hello!");
  }
</script>



Переменные:

<button onclick="foo()">Click me!</button>

<script>
  var x = 1;

  function foo() {
    alert(x);
    x = x+1;
  }
</script>



классы содержат данные, имеют методы, которые взаимодействуют с этими данными и используются для того, чтобы создавать объекты на основе этих классов
объект - это экземпляр класса. для некоторых - это коренной класс руби Object
модуль - механизм, который служит для namespaces (пространства имён) module/end - Namespace::Class.method. Ещё, модули предоставляют механизм для множественного наследования с помощью миксинов. module/end - extend
три уровня доступа для модулей и классов: public - по умолчанию, protected, private - методы доступные только внутри самого класса



для того что бы не писать js функцию в нескольких html файлах ,создадим файл js в public и в layut файле напишем ссылку  <script src="/fr.js"></script>
теперь можно ссылкатся на данный файл с помощью названия метода

<button class="btn btn-primary "onclick="something()">Button</button>

function foo() {
  var x = window.localStorage.getItem('score');

  window.localStorage.setItem('score', 555);

  alert(x);
} использование local storage

Интерфейс Storage из Web Storage API предоставляет доступ для session
storage или local storage для конкретного домена, позволяя вам к 
примеру добавлять,
изменять или удалять сохранённые элементы данных.

Свойства
Storage.length Только для чтения
Возвращает число, представляющее количество элементов в объекте Storage.

Методы
Storage.key()
Приняв число n, метод вернёт имя n-ного ключа в Storage

Storage.getItem()
Приняв имя ключа, метод вернёт для него значение.

Storage.setItem()
Приняв имя ключа и значение, метод добавит этот ключ в Storage или обновит его значение, если ключ уже существовал.

Storage.removeItem()
Приняв имя ключа, метод удалит этот ключ из Storage

Storage.clear()
При вызове метод удалит все ключи из Storage.





function foo() {
  var x = window.localStorage.getItem('score'); // это как x = hh['score'] в ruby

  // x * 1 - чтобы преобразовать строку в число  ,без данной строчки js будет думать что  x+1 строки
  x = x * 1 + 1;

  window.localStorage.setItem('score', x); // hh['score'] = x

  alert(x);
}





        типы данных в sql
:primary_key
:text
:integer
:float
:decimal
:datetime
:timestamp
:time
:date
:binary
:boolean




использование разных типов данных


# + to db/migrate/9279387982_create_products.rb

class CreateProducts < ActiveRecord::Migration[5.2]
  def change
    create_table :products do |t|
      t.string :title
      t.text :description
      t.decimal :price
      t.decimal :size
      t.boolean :is_spicy
      t.boolean :is_veg
      t.boolean :is_best_offer
      t.string :path_to_image

      t.timestamps
    end
  end
end



Seed database. Наполним вручную базу данных
rake db:create_migration NAME=add_products
# + to db/migrate/786238472_add_products.rb

class AddProducts < ActiveRecord::Migration[5.2]
  def change
    Product.create :title => 'Гавайская',
      :description => 'Это гавайская пицца',
      :price => 350,
      :size => 30,
      :is_spicy => false,
      :is_veg => false,
      :is_best_offer => false,
      :path_to_image => '/images/01.jpg'

    Product.create :title => 'Пепперони',
      :description => 'Это пицца Пепперони',
      :price => 450,
      :size => 30,
      :is_spicy => false,
      :is_veg => false,
      :is_best_offer => true,
      :path_to_image => '/images/02.jpg'

    Product.create :title => 'Вегетарианская',
      :description => 'Это вегетарианская пицца',
      :price => 400,
      :size => 30,
      :is_spicy => false,
      :is_veg => true,
      :is_best_offer => false,
      :path_to_image => '/images/03.jpg'
  end
end
И, сделаем:

rake db:migrate




три способа вызвать метод в руби:
# 1
object = Object.new
puts object.object_id

# 2
puts object.send(:object_id)

# 3
puts object.method(:object_id).call


737


a ||= b является условным оператором присваивания . Это значит:

если a не определено или ложно , то оцените b и установите a результат.
В противном случае (если a определено и оценивается как истинное), то b не оценивается, и присваивание не происходит.
Например:

a ||= nil # => nil
a ||= 0 # => 0
a ||= 2 # => 0

foo = false # => false
foo ||= true # => true
foo ||= false # => true
Как ни странно, он похож на другие операторы присваивания (такие как +=), но ведет себя иначе.

a += b переводится как a = a + b
a ||= b примерно переводится как a || a = b
Это почти сокращение от a || a = b. Разница в том, что когда aне определено,
 a || a = b будет повышаться NameError, тогда как a ||= b устанавливается a в b.
 Это различие не имеет значения, если aи bявляются локальными переменными, но имеет значение,
 если любой из них является методом получения/установки класса.

x ||= y
Это сокращённо:

x = x || y
Что означает:

x || y
|| - логическое ИЛИ

if x == 1 || x == 2
Срабатывает первое условие, если не срабатывает, берёт второе условие:

nil || 4 #=> 4
false || 2 #=> 2
123 || 2 #=> 123

x = x || 4
x = false
x = x || 2
puts x
#=> 2

x = true
x = x || 2
puts x
#=> true

x = 5
x = x || 2 # это мы можем заменить на x ||= 2
puts x
#=> 5

x = 5
x ||= 2
puts x
#=> 5
x ||= y используется для установки значения по умолчанию

Что такое self? self всегда указывает на текущий объект. Может быть вызван без создания объекта.
class WhatIsSelf
  def test
    puts "At the instance level, self is #{self}"
  end

  def self.test
    puts "At the class level, self is #{self}"
  end
end

WhatIsSelf.test
 #=> At the class level, self is WhatIsSelf

WhatIsSelf.new.test
 #=> At the instance level, self is #<WhatIsSelf:0x28190>



Что такое Proc? Процедура. Три типа:
анонимные методы (функции без имени)
lambda
блок
# wants a proc, a lambda, AND a block
def three_ways(proc, lambda, &block)
  proc.call
  lambda.call
  yield # like block.call
  puts "#{proc.inspect} #{lambda.inspect} #{block.inspect}"
end

anonymous = Proc.new { puts "I'm a Proc for sure." }
nameless  = lambda { puts "But what about me?" }

three_ways(anonymous, nameless) do
  puts "I'm a block, but could it be???"
end
 #=> I'm a Proc for sure.
 #=> But what about me?
 #=> I'm a block, but could it be???
 #=> #<Proc:0x00089d64> #<Proc:0x00089c74> #<Proc:0x00089b34>


grid 
условно разделяет страницу на 12 частей

md-midle for ipad
sm-small for phone
lg-large for pc

сol-md-2 обозначает столбец будет занимать длинну 4 едениц


вывод содержимого бд

<h3>Welcome to the PizzaHot</h3>

<div class= "row">
	<% @product.each do |p| %>
		<div class="col-md-3">
			<div>
				<%=p.title %>
			</div>

			<div>
				<img src="<%= p.path_to_image %>" width="265", height="200"-установка параметров для иображения  />   вывод изображения
			</div>

			<div>
				<%=p.discription %>
			</div>

			<div>
				<%=p.price %>
			</div>

			<div>
				<%=p.is_spicy %>
			</div>

			<div>
				<%=p.is_veg %>
			</div>

			<div>
				<%=p.is_best_offer %>
			</div>
			
		</div>
		
	<% end %>
</div>

<br />
<button class="btn btn-primary "onclick="something()">Button</button> 

нам надо создать корзину, но чтобы при закрытии браузера данные сохранялись.
Помежуточная проверка работает ли кнопка:
добовляем кнопку в цикл 
<p><button onclick="alert('hello')">Добавить в корзину</button></p>

Number 2:
в js файле создаем новую функцию:

function add_to_cart() {
  alert('hello all!');
}
изменяем кнопку :

<p><button onclick="add_to_cart()">Добавить в корзину</button></p>


глюк в js файле и его устранение

javascript file :
  function cart()
{
	alert ('Hello from function');
}        
  html file: 
    		   <div>
				<button class="btn  btn-success "onclick="cart()">Add to cart</button>
			</div>



			браузер выводит данную ошибку Uncaught ReferenceError: cart is not defined(браузер не видит функцию в js файле
в результате чего add_to_cart не инициализируется)
			
      ошибка в результате вывода данного кода


1 стоит создать новый js файл поместить туда нужный код и сделать на него ссылку 

2 написать функцию в html файл использую  тег скрипт


добавление параметра в функцию 
js файл
таким образом каждому обьекту (пицце) будет присвоен уникальный идентификатор
function add_to_cart(id)
{
	alert ('You added pizza with id:'+id);
}

html файл

<div>
				<button class="btn  btn-success "onclick="add_to_cart(<%=p.id%>)">Add to cart</button>  #задаем параметр
			</div>
 


Структура данных для нашей корзины заказа в PizzaShop - хеш:
key - id продукта
value - количество
Перед написанием на js напишем на ruby:

order = {}

loop do
  print 'Введите id продукта: '
  id_product = gets.strip

  print "Сколько штук вы хотите заказать: "
  amount_now = gets.strip.to_i

  amount = order[id_product].to_i
  amount += amount_now

  order[id_product] = amount

  puts order.inspect
end



На сервер мы будем передавать строку.

1 = 5, 2 = 12, 3 = 0



Теперь напишем это на JS:

function add_to_cart(id)
{
	var x = window.localStorage.getItem('product'+ id)  # вывод будет следующим product 1,product 2
	x = x * 1 + 1;  операция означает что переменная будет увеличиватся на еденицу с каждым нажатием
	window.localStorage.setItem('product_'+id ,x) id продукта key,добавление в хэш значения x  value
}
}


как проверить наличие элементов в local storage  f 12 в браузере для открытия консоли и прописать команду localstorage
localStorage.clear(); данная команда удалит из него все данные
 ( Свойство localStorage позволяет получить доступ к Storage объекту -хранилище данных)
в отличие от session storage (хранит данные в течении одного сеанса)  local storage хранит данные перманентно (размер хранилища 5 мб)


function add_to_cart(id)
{
	var key='product_'+ id; добавляем key в отдельную переменную 

	var x = window.localStorage.getItem(key);
	x = x * 1 + 1;
	window.localStorage.setItem('product_' + id, x);
}	
	


Итак, если вы хотите правильно перечислить элементы с ключом, соответствующим шаблону, используйте

function listFavs(){
    var key;
    for (var i = 0, len = localStorage.length; i < len; i++){
        key = localStorage.key(i);
        if ((/^saved-fav-title_/).test(key)) {
            console.log(localStorage.getItem(key);
        }
   }
}


Кратко о том, что делает функция:

Создает переменную key, которая будет использоваться для хранения ключа текущего элемента Local Storage.
Проходится по всем элементам Local Storage, используя цикл for.
Для каждого элемента вызывает метод localStorage.key(i), который возвращает ключ текущего элемента.
Проверяет, начинается ли ключ с "saved-fav-title_" с помощью регулярного выражения (/^saved-fav-title_/).
Если ключ соответствует условию, то выводит значение элемента Local Storage с помощью метода localStorage.getItem(key).



// + to public/js/main.js

function cart_get_number_of_items()
{
  var cnt = 0;

  for (var i = 0; i < window.localStorage.length; i++)
  {
    var key = window.localStorage.key(i); // получаем ключ
    var value = window.localStorage.getItem(key); // получаем значение

    if(key.indexOf('product_') == 0)
    {
      cnt = cnt + value * 1;
    }
  }

  return cnt;
}

for-цикл

for(var i=;)- var i=0 аналог each

var key = window.localStorage.key(i) получим название ключа
var value = window.localStorage.getItem(key) -получим значение

key.indexOf('product_')-возвращает номер позиции с которого начинается выражение
key.indexOf('product_')==0 -проверка true false

if (key.indexOf('product_') == 0) on js




teg <a>- anchor (якорь) ссылка



3 способа написания button 


<a class="btn...
<button class="btn..
<input type="submit"


создание кнопки для корзины в layut
<ul class="nav navbar-nav navbar-right">
	<li><input type="submit" class="btn btn-primary btn-lg " value="Cart(.. )"></li>
</ul>

<ul> 	class="class="nav navbar-nav navbar-right">"
   <li>
	<form action="/cart" method="post">   #добовляем форму
	<input name="orders" type="text" value   # добовляем поле куда будем записывать кол-во пицц
	<input type="submit" class="btn btn-primary btn-lg " value="Cart(.. )">
   </li>
</ul>


 создаем функцию в js файле 
function cart_get_orders()
{
  var orders = '' ; задаем переменрную в которую будем складывать все значения

  for (var i = 0; i < window.localStorage.length; i++)
  {
    var key = window.localStorage.key(i); 
    var value = window.localStorage.getItem(key); 

    if(key.indexOf('product_') == 0)
    {
      orders = orders + key + '=' + value + ','; # таким образом в ордерс помещаем все key and value значени
    }
  }

  return orders;
}

далее создаем функцию
function update_orders_input()
{
	var orders = cart_get_orders();
	$('#orders_input').val(orders);  #val(orders) установка значения
}

<input id="orders_input" name="orders" type="text" value   # для того что бы обратится из java скрипта задаем атрибут  id 



function add_to_cart(id)
{
	var key='product_'+ id; 

	var x = window.localStorage.getItem(key);
	x = x * 1 + 1;
	window.localStorage.setItem(key, x);

	update_orders_input(); # добовляем название функции для взаимодействия  
   
}


<ul>    class="class="nav navbar-nav navbar-right">"
   <li>
        <form action="/cart" method="post">   #
        <input name="orders" type="hidden" /> заменяем type="text" на type="hidden" - делая текст скрытым
        <input type="submit" class="btn btn-primary btn-lg " value="Cart(.. )">
   </li>
</ul>


<ul>    class="class="nav navbar-nav navbar-right">"
   <li>
        <form action="/cart" method="post">   #
        <input name="orders" type="hidden" /> заменяем type="text" на type="hidden" - делая текст скрытым
        <input id="orders_button" type="submit" class="btn btn-primary btn-lg " value="Cart(.. )">    #добавляем id
   </li>
</ul>


value="Cart(.. )">  в скобках будет кол-во itemov в корзине 

создаем функциюю
function update_orders_button()
{
  var text = 'Cart (' + cart_get_number_of_items() + ')';
  $('#orders_button'). val(text);  
}


function add_to_cart(id)
{
        var key='product_'+ id; 

        var x = window.localStorage.getItem(key);
        x = x * 1 + 1;
        window.localStorage.setItem(key, x);

        update_orders_input(); 
  update_orders_button();                 и добовляем в функцию
   
}





Чтобы установить конкретную версию, введите (вместо rails_version - номер версии):

gem install rails -v rails_version


С помощью gemset-ов можно использовать вместе разные версии Rails и Ruby. Это делается с помощью команды gem.

rvm gemset create gemset_name # create a gemset
rvm ruby_version@gemset_name  # specify Ruby version and our new gemset

Gemset-ы позволяют создавать полнофункциональные окружения для gem-ов,
 а также настраивать 
неограниченное количество окружений для каждой версии Ruby.

rails приложение может запускатся в разном окружении

Rails-приложение может запускаться в 3 типах окружения:
development- не будет доп не нужных вещей,работает быстро и оптимизирует работу
test   -будет вместо обычной базы данных тестовая база данных
production

при разработке приложения на rails ,настройки rails позволяют оптимизировать среду таким образом
что бы было удобно разрабатывать программы

Создадим новое рейлс-приложение:
rails new blog


rails server запус сервера rails

start rals server запуск сервера рэйлс в новом окне

 MVC
Model, View, Controller

Controller - отвечает за работу с какой-либо сущностью

Создадим контроллер:
rails generate controller home index
Найдём файл /app/controllers/home_controller.rb

Найдём файл /app/views/home/index.html.erb

Откроем в браузере: http://localhost:3000/home/index

Обычно /home/index создаётся для главной страницы сайта Надо открыть /config/routes.rb и прописать:

Rails.application.routes.draw do
  get '/' => 'home#index'
end
 




Что такое юнит-тесты. Юнит-тесты предназначены для тестирования отдельных модулей программы (к частям, которые не делимы).
require "test/unit"

class Brokened
  def uh_oh
    "I needs fixing"
  end
end

class BrokenedTest < Test::Unit::TestCase
  def test_uh_oh
    actual = Brokened.new
    assert_equal("I'm all better!", actual.uh_oh)
  end
end
 #=> Started
 #=> F
 #=> Finished in 0.663831 seconds.
 #=>
 #=>   1) Failure:
 #=> test_uh_oh:11
 #=> <"I'm all better!"> expected but was
 #=> <"I needs fixing">.
 #=>
 #=> 1 tests, 1 assertions, 1 failures, 0 errors
Вызываем метод и проверяем, что результат совпадает с эталоном

test coverage - покрытие тестами

Интеграционное тестирование - тестирование сайта в браузере

Как много надо покрывать кода тестами?

Юнит тестирование нужно, чтобы при возрастании сложности приложения функциональность большого приложения сохранялась.

Статическая и динамическая типизация
// Java
public boolean isEmpty(String s) {
  return s.length() == 0;
}
# ruby
def empty?(s)
  return s.size == 0
end
В руби меньше кода и он более гибкий.


	переносим инициализацию продуктов из корзины  в layaut (что бы код был доступен во всех программе)
 <script type="text/javascript">
	$(function() {
		update_orders_input();
		update_orders_button(); 
  
	});
</script> 



HTTP запросы:

GET /cart?...&...
POST
PUT
DELETE
GET, POST можно отправлять с помощью form

PUT, DELETE через POST с добавлением скрытой переменной.


Паттерн REST - передача состояния объекта

В REST существует 7 различных методов с помощью которых можно управлять объектами:

index
show
new
create
edit
update
destroy



REST product:

index - /products - все наши продукты - get
show - /products/1 - конкретный продукт - get
new - /products/new - вывод формы для создания - get
create - /products - создание продукта, обращ. к params и в БД создаёт запись - post
edit - /products/1/edit - возвращает форму для редактирования определённого продукта - get
update - /products/1 - put
destroy - /produts/1 - delete




при использовании метода new нужно сделать 213.save

при использовании метода create нет


Очистим корзину после того как заказ был отправлен и добавим кнопку очистки корзины.

# + post '/cart'

# если корзина пустая
if @items.length == 0
  return erb "В корзине нет товаров"
end

# view
<script type="text/javascript">
	
$(function() {
	window.localStorage.clear();

});


</script>