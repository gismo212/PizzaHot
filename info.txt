Порт - это абстракция операционной системы, или абстракция протокола.

1. Resolve domain if not an IP (DNS query)
2. Open port 80 by default if not SSL and not overridden by a colon (http: //host:port/)
3. Send request (#1) for http: //host/uri/here?other=stuff&too
4. Receive response (#2)
5. Close
Порты:

80 - http
443 - https




браузер получает запрос от пользователя и url преобразует в ip адрес
Запрос:

GET /uri/here?other=stuff&too HTTP/1.1
Host: host
Other: Headers, too.  Such as cookies
Header: Value
Ответ:

HTTP/1.1 200 OK
Other: Headers, too.  Such as cookies
Header: Value

<html>Actual HTTP payload is here, could be HTML data, downloaded file data, etc.


what happens when you type in a URL in browser
1. browser checks cache; if requested object is in cache and is fresh, skip to #9
2. browser asks OS for server's IP address
3. OS makes a DNS lookup and replies the IP address to the browser
4. browser opens a TCP connection to server (this step is much more complex with HTTPS)
5. browser sends the HTTP request through TCP connection
6. browser receives HTTP response and may close the TCP connection, or reuse it for another request
7. browser checks if the response is a redirect or a conditional response (3xx result status codes), authorization request (401), error (4xx and 5xx), etc.; these are handled differently from normal responses (2xx)
8. if cacheable, response is stored in cache
9. browser decodes response (e.g. if it's gzipped)
10. browser determines what to do with response (e.g. is it a HTML page, is it an image, is it a sound clip?)
11. browser renders response, or offers a download dialog for unrecognized types




В JS функция вызывается по хэндлеру/событию (обработчик):

<button onclick="foo()">Click me!</button>

что писать js функцию в html коде указываем тег script
<script>
  function foo() {
    alert("Hello!");
  }
</script>



Переменные:

<button onclick="foo()">Click me!</button>

<script>
  var x = 1;

  function foo() {
    alert(x);
    x = x+1;
  }
</script>



классы содержат данные, имеют методы, которые взаимодействуют с этими данными и используются для того, чтобы создавать объекты на основе этих классов
объект - это экземпляр класса. для некоторых - это коренной класс руби Object
модуль - механизм, который служит для namespaces (пространства имён) module/end - Namespace::Class.method. Ещё, модули предоставляют механизм для множественного наследования с помощью миксинов. module/end - extend
три уровня доступа для модулей и классов: public - по умолчанию, protected, private - методы доступные только внутри самого класса



для того что бы не писать js функцию в нескольких html файлах ,создадим файл js в public и в layut файле напишем ссылку  <script src="/fr.js"></script>
теперь можно ссылкатся на данный файл с помощью названия метода

<button class="btn btn-primary "onclick="something()">Button</button>

function foo() {
  var x = window.localStorage.getItem('score');

  window.localStorage.setItem('score', 555);

  alert(x);
} использование local storage

Интерфейс Storage из Web Storage API предоставляет доступ для session
storage или local storage для конкретного домена, позволяя вам к 
примеру добавлять,
изменять или удалять сохранённые элементы данных.

Свойства
Storage.length Только для чтения
Возвращает число, представляющее количество элементов в объекте Storage.

Методы
Storage.key()
Приняв число n, метод вернёт имя n-ного ключа в Storage

Storage.getItem()
Приняв имя ключа, метод вернёт для него значение.

Storage.setItem()
Приняв имя ключа и значение, метод добавит этот ключ в Storage или обновит его значение, если ключ уже существовал.

Storage.removeItem()
Приняв имя ключа, метод удалит этот ключ из Storage

Storage.clear()
При вызове метод удалит все ключи из Storage.





function foo() {
  var x = window.localStorage.getItem('score'); // это как x = hh['score'] в ruby

  // x * 1 - чтобы преобразовать строку в число  ,без данной строчки js будет думать что  x+1 строки
  x = x * 1 + 1;

  window.localStorage.setItem('score', x); // hh['score'] = x

  alert(x);
}





        типы данных в sql
:primary_key
:text
:integer
:float
:decimal
:datetime
:timestamp
:time
:date
:binary
:boolean




использование разных типов данных


# + to db/migrate/9279387982_create_products.rb

class CreateProducts < ActiveRecord::Migration[5.2]
  def change
    create_table :products do |t|
      t.string :title
      t.text :description
      t.decimal :price
      t.decimal :size
      t.boolean :is_spicy
      t.boolean :is_veg
      t.boolean :is_best_offer
      t.string :path_to_image

      t.timestamps
    end
  end
end



Seed database. Наполним вручную базу данных
rake db:create_migration NAME=add_products
# + to db/migrate/786238472_add_products.rb

class AddProducts < ActiveRecord::Migration[5.2]
  def change
    Product.create :title => 'Гавайская',
      :description => 'Это гавайская пицца',
      :price => 350,
      :size => 30,
      :is_spicy => false,
      :is_veg => false,
      :is_best_offer => false,
      :path_to_image => '/images/01.jpg'

    Product.create :title => 'Пепперони',
      :description => 'Это пицца Пепперони',
      :price => 450,
      :size => 30,
      :is_spicy => false,
      :is_veg => false,
      :is_best_offer => true,
      :path_to_image => '/images/02.jpg'

    Product.create :title => 'Вегетарианская',
      :description => 'Это вегетарианская пицца',
      :price => 400,
      :size => 30,
      :is_spicy => false,
      :is_veg => true,
      :is_best_offer => false,
      :path_to_image => '/images/03.jpg'
  end
end
И, сделаем:

rake db:migrate




три способа вызвать метод в руби:
# 1
object = Object.new
puts object.object_id

# 2
puts object.send(:object_id)

# 3
puts object.method(:object_id).call


737


a ||= b является условным оператором присваивания . Это значит:

если a не определено или ложно , то оцените b и установите aрезультат.
В противном случае (если aопределено и оценивается как истинное), то b не оценивается, и присваивание не происходит.
Например:

a ||= nil # => nil
a ||= 0 # => 0
a ||= 2 # => 0

foo = false # => false
foo ||= true # => true
foo ||= false # => true
Как ни странно, он похож на другие операторы присваивания (такие как +=), но ведет себя иначе.

a += bпереводится какa = a + b
a ||= bпримерно переводится какa || a = b
Это почти сокращение от a || a = b. Разница в том, что когда aне определено,
 a || a = bбудет повышаться NameError, тогда как a ||= bустанавливается aв b.
 Это различие не имеет значения, если aи bявляются локальными переменными, но имеет значение,
 если любой из них является методом получения/установки класса.

x ||= y
Это сокращённо:

x = x || y
Что означает:

x || y
|| - логическое ИЛИ

if x == 1 || x == 2
Срабатывает первое условие, если не срабатывает, берёт второе условие:

nil || 4 #=> 4
false || 2 #=> 2
123 || 2 #=> 123

x = x || 4
x = false
x = x || 2
puts x
#=> 2

x = true
x = x || 2
puts x
#=> true

x = 5
x = x || 2 # это мы можем заменить на x ||= 2
puts x
#=> 5

x = 5
x ||= 2
puts x
#=> 5
x ||= y используется для установки значения по умолчанию

Что такое self? self всегда указывает на текущий объект. Может быть вызван без создания объекта.
class WhatIsSelf
  def test
    puts "At the instance level, self is #{self}"
  end

  def self.test
    puts "At the class level, self is #{self}"
  end
end

WhatIsSelf.test
 #=> At the class level, self is WhatIsSelf

WhatIsSelf.new.test
 #=> At the instance level, self is #<WhatIsSelf:0x28190>



Что такое Proc? Процедура. Три типа:
анонимные методы (функции без имени)
lambda
блок
# wants a proc, a lambda, AND a block
def three_ways(proc, lambda, &block)
  proc.call
  lambda.call
  yield # like block.call
  puts "#{proc.inspect} #{lambda.inspect} #{block.inspect}"
end

anonymous = Proc.new { puts "I'm a Proc for sure." }
nameless  = lambda { puts "But what about me?" }

three_ways(anonymous, nameless) do
  puts "I'm a block, but could it be???"
end
 #=> I'm a Proc for sure.
 #=> But what about me?
 #=> I'm a block, but could it be???
 #=> #<Proc:0x00089d64> #<Proc:0x00089c74> #<Proc:0x00089b34>


grid 
условно разделяет страницу на 12 частей

md-midle for ipad
sm-small for phone
lg-large for pc

сol-md-2 обозначает столбец будет занимать длинну 4 едениц




вывод содержимого бд

<h3>Welcome to the PizzaHot</h3>

<div class= "row">
	<% @product.each do |p| %>
		<div class="col-md-3">
			<div>
				<%=p.title %>
			</div>

			<div>
				<img src="<%= p.path_to_image %>" width="265", height="200"-установка параметров для иображения  />   вывод изображения
			</div>

			<div>
				<%=p.discription %>
			</div>

			<div>
				<%=p.price %>
			</div>

			<div>
				<%=p.is_spicy %>
			</div>

			<div>
				<%=p.is_veg %>
			</div>

			<div>
				<%=p.is_best_offer %>
			</div>
			
		</div>
		
	<% end %>
</div>

<br />
<button class="btn btn-primary "onclick="something()">Button</button> 

нам надо создать корзину, но чтобы при закрытии браузера данные сохранялись.
Помежуточная проверка работает ли кнопка:
добовляем кнопку в цикл 
<p><button onclick="alert('hello')">Добавить в корзину</button></p>

Number 2:
в js файле создаем новую функцию:

function add_to_cart() {
  alert('hello all!');
}
изменяем кнопку :

<p><button onclick="add_to_cart()">Добавить в корзину</button></p>


глюк в js файле и его устранение

javascript file :
  function cart()
{
	alert ('Hello from function');
}        
  html file: 
    		   <div>
				<button class="btn  btn-success "onclick="cart()">Add to cart</button>
			</div>



			браузер выводит данную ошибку Uncaught ReferenceError: cart is not defined(браузер не видит функцию в js файле
в результате чего add_to_cart не инициализируется)
			
      ошибка в результате вывода данного кода


1 стоит создать новый js файл поместить туда нужный код и сделать на него ссылку 

2 написать функцию в html файл использую  тег скрипт


добавление параметра в функцию 
js файл
таким образом каждому обьекту (пицце) будет присвоен уникальный идентификатор
function add_to_cart(id)
{
	alert ('You added pizza with id:'+id);
}

html файл

<div>
				<button class="btn  btn-success "onclick="add_to_cart(<%=p.id%>)">Add to cart</button>  #задаем параметр
			</div>
 


Структура данных для нашей корзины заказа в PizzaShop - хеш:
key - id продукта
value - количество
Перед написанием на js напишем на ruby:

order = {}

loop do
  print 'Введите id продукта: '
  id_product = gets.strip

  print "Сколько штук вы хотите заказать: "
  amount_now = gets.strip.to_i

  amount = order[id_product].to_i
  amount += amount_now

  order[id_product] = amount

  puts order.inspect
end



На сервер мы будем передавать строку.

1 = 5, 2 = 12, 3 = 0



Теперь напишем это на JS:

function add_to_cart(id)
{
	var x = window.localStorage.getItem('product'+ id)  # вывод будет следующим product 1,product 2
	x = x * 1 + 1;  операция означает что переменная будет увеличиватся на еденицу с каждым нажатием
	window.localStorage.setItem('product_'+id ,x) id продукта key,добавление в хэш значения x  value
}
}


как проверить наличие элементов в local storage  f 12 в браузере для открытия консоли и прописать команду localstorage
localStorage.clear(); данная команда удалит из него все данные
 ( Свойство localStorage позволяет получить доступ к Storage объекту -хранилище данных)
в отличие от session storage (хранит данные в течении одного сеанса)  local storage хранит данные перманентно (размер хранилища 5 мб)


function add_to_cart(id)
{
	var key='product_'+ id; добавляем key в отдельную переменную 

	var x = window.localStorage.getItem(key);
	x = x * 1 + 1;
	window.localStorage.setItem('product_' + id, x);
}	
	


Итак, если вы хотите правильно перечислить элементы с ключом, соответствующим шаблону, используйте

function listFavs(){
    var key;
    for (var i = 0, len = localStorage.length; i < len; i++){
        key = localStorage.key(i);
        if ((/^saved-fav-title_/).test(key)) {
            console.log(localStorage.getItem(key);
        }
   }
}


Кратко о том, что делает функция:

Создает переменную key, которая будет использоваться для хранения ключа текущего элемента Local Storage.
Проходится по всем элементам Local Storage, используя цикл for.
Для каждого элемента вызывает метод localStorage.key(i), который возвращает ключ текущего элемента.
Проверяет, начинается ли ключ с "saved-fav-title_" с помощью регулярного выражения (/^saved-fav-title_/).
Если ключ соответствует условию, то выводит значение элемента Local Storage с помощью метода localStorage.getItem(key).



// + to public/js/main.js

function cart_get_number_of_items()
{
  var cnt = 0;

  for (var i = 0; i < window.localStorage.length; i++)
  {
    var key = window.localStorage.key(i); // получаем ключ
    var value = window.localStorage.getItem(key); // получаем значение

    if(key.indexOf('product_') == 0)
    {
      cnt = cnt + value * 1;
    }
  }

  return cnt;
}

for-цикл

for(var i=;)- var i=0 аналог each

var key = window.localStorage.key(i) получим название ключа
var value = window.localStorage.getItem(key) -получим значение

key.indexOf('product_')-возвращает номер позиции с которого начинается выражение
key.indexOf('product_')==0 -проверка true false

if (key.indexOf('product_') == 0) on js




teg <a>- anchor (якорь) ссылка



3 способа написания button 


<a class="btn...
<button class="btn..
<input type="submit"


создание кнопки для корзины в layut
<ul class="nav navbar-nav navbar-right">
			    	<li><input type="submit" class="btn btn-primary btn-lg " value="Cart(.. )"></li>
			    </ul>