Порт - это абстракция операционной системы, или абстракция протокола.

1. Resolve domain if not an IP (DNS query)
2. Open port 80 by default if not SSL and not overridden by a colon (http: //host:port/)
3. Send request (#1) for http: //host/uri/here?other=stuff&too
4. Receive response (#2)
5. Close
Порты:

80 - http
443 - https




браузер получает запрос от пользователя и url преобразует в ip адрес
Запрос:

GET /uri/here?other=stuff&too HTTP/1.1
Host: host
Other: Headers, too.  Such as cookies
Header: Value
Ответ:

HTTP/1.1 200 OK
Other: Headers, too.  Such as cookies
Header: Value

<html>Actual HTTP payload is here, could be HTML data, downloaded file data, etc.


what happens when you type in a URL in browser
1. browser checks cache; if requested object is in cache and is fresh, skip to #9
2. browser asks OS for server's IP address
3. OS makes a DNS lookup and replies the IP address to the browser
4. browser opens a TCP connection to server (this step is much more complex with HTTPS)
5. browser sends the HTTP request through TCP connection
6. browser receives HTTP response and may close the TCP connection, or reuse it for another request
7. browser checks if the response is a redirect or a conditional response (3xx result status codes), authorization request (401), error (4xx and 5xx), etc.; these are handled differently from normal responses (2xx)
8. if cacheable, response is stored in cache
9. browser decodes response (e.g. if it's gzipped)
10. browser determines what to do with response (e.g. is it a HTML page, is it an image, is it a sound clip?)
11. browser renders response, or offers a download dialog for unrecognized types




В JS функция вызывается по хэндлеру/событию (обработчик):

<button onclick="foo()">Click me!</button>

что писать js функцию в html коде указываем тег script
<script>
  function foo() {
    alert("Hello!");
  }
</script>



Переменные:

<button onclick="foo()">Click me!</button>

<script>
  var x = 1;

  function foo() {
    alert(x);
    x = x+1;
  }
</script>



классы содержат данные, имеют методы, которые взаимодействуют с этими данными и используются для того, чтобы создавать объекты на основе этих классов
объект - это экземпляр класса. для некоторых - это коренной класс руби Object
модуль - механизм, который служит для namespaces (пространства имён) module/end - Namespace::Class.method. Ещё, модули предоставляют механизм для множественного наследования с помощью миксинов. module/end - extend
три уровня доступа для модулей и классов: public - по умолчанию, protected, private - методы доступные только внутри самого класса



для того что бы не писать js функцию в нескольких html файлах ,создадим файл js в public и в layut файле напишем ссылку  <script src="/fr.js"></script>
теперь можно ссылкатся на данный файл с помощью названия метода

<button class="btn btn-primary "onclick="something()">Button</button>

function foo() {
  var x = window.localStorage.getItem('score');

  window.localStorage.setItem('score', 555);

  alert(x);
} использование local storage




function foo() {
  var x = window.localStorage.getItem('score'); // это как x = hh['score'] в ruby

  // x * 1 - чтобы преобразовать строку в число  ,без данной строчки js будет думать что  x+1 строки
  x = x * 1 + 1;

  window.localStorage.setItem('score', x); // hh['score'] = x

  alert(x);
}


        типы данных в sql
:primary_key
:text
:integer
:float
:decimal
:datetime
:timestamp
:time
:date
:binary
:boolean




использование разных типов данных


# + to db/migrate/9279387982_create_products.rb

class CreateProducts < ActiveRecord::Migration[5.2]
  def change
    create_table :products do |t|
      t.string :title
      t.text :description
      t.decimal :price
      t.decimal :size
      t.boolean :is_spicy
      t.boolean :is_veg
      t.boolean :is_best_offer
      t.string :path_to_image

      t.timestamps
    end
  end
end



Seed database. Наполним вручную базу данных
rake db:create_migration NAME=add_products
# + to db/migrate/786238472_add_products.rb

class AddProducts < ActiveRecord::Migration[5.2]
  def change
    Product.create :title => 'Гавайская',
      :description => 'Это гавайская пицца',
      :price => 350,
      :size => 30,
      :is_spicy => false,
      :is_veg => false,
      :is_best_offer => false,
      :path_to_image => '/images/01.jpg'

    Product.create :title => 'Пепперони',
      :description => 'Это пицца Пепперони',
      :price => 450,
      :size => 30,
      :is_spicy => false,
      :is_veg => false,
      :is_best_offer => true,
      :path_to_image => '/images/02.jpg'

    Product.create :title => 'Вегетарианская',
      :description => 'Это вегетарианская пицца',
      :price => 400,
      :size => 30,
      :is_spicy => false,
      :is_veg => true,
      :is_best_offer => false,
      :path_to_image => '/images/03.jpg'
  end
end
И, сделаем:

rake db:migrate




три способа вызвать метод в руби:
# 1
object = Object.new
puts object.object_id

# 2
puts object.send(:object_id)

# 3
puts object.method(:object_id).call


737


a ||= b является условным оператором присваивания . Это значит:

если a не определено или ложно , то оцените b и установите aрезультат.
В противном случае (если aопределено и оценивается как истинное), то b не оценивается, и присваивание не происходит.
Например:

a ||= nil # => nil
a ||= 0 # => 0
a ||= 2 # => 0

foo = false # => false
foo ||= true # => true
foo ||= false # => true
Как ни странно, он похож на другие операторы присваивания (такие как +=), но ведет себя иначе.

a += bпереводится какa = a + b
a ||= bпримерно переводится какa || a = b
Это почти сокращение от a || a = b. Разница в том, что когда aне определено,
 a || a = bбудет повышаться NameError, тогда как a ||= bустанавливается aв b.
 Это различие не имеет значения, если aи bявляются локальными переменными, но имеет значение,
 если любой из них является методом получения/установки класса.




Что такое self? self всегда указывает на текущий объект. Может быть вызван без создания объекта.
class WhatIsSelf
  def test
    puts "At the instance level, self is #{self}"
  end

  def self.test
    puts "At the class level, self is #{self}"
  end
end

WhatIsSelf.test
 #=> At the class level, self is WhatIsSelf

WhatIsSelf.new.test
 #=> At the instance level, self is #<WhatIsSelf:0x28190>



Что такое Proc? Процедура. Три типа:
анонимные методы (функции без имени)
lambda
блок
# wants a proc, a lambda, AND a block
def three_ways(proc, lambda, &block)
  proc.call
  lambda.call
  yield # like block.call
  puts "#{proc.inspect} #{lambda.inspect} #{block.inspect}"
end

anonymous = Proc.new { puts "I'm a Proc for sure." }
nameless  = lambda { puts "But what about me?" }

three_ways(anonymous, nameless) do
  puts "I'm a block, but could it be???"
end
 #=> I'm a Proc for sure.
 #=> But what about me?
 #=> I'm a block, but could it be???
 #=> #<Proc:0x00089d64> #<Proc:0x00089c74> #<Proc:0x00089b34>



вывод содержимого бд

<h3>Welcome to the PizzaHot</h3>

<div class= "row">
	<% @product.each do |p| %>
		<div class="col-md-3">
			<div>
				<%=p.title %>
			</div>

			<div>
				<img src="<%= p.path_to_image %>" width="265", height="200"-установка параметров для иображения  />   вывод изображения
			</div>

			<div>
				<%=p.discription %>
			</div>

			<div>
				<%=p.price %>
			</div>

			<div>
				<%=p.is_spicy %>
			</div>

			<div>
				<%=p.is_veg %>
			</div>

			<div>
				<%=p.is_best_offer %>
			</div>
			
		</div>
		
	<% end %>
</div>

<br />
<button class="btn btn-primary "onclick="something()">Button</button> 

нам надо создать корзину, но чтобы при закрытии браузера данные сохранялись.
Помежуточная проверка работает ли кнопка:
добовляем кнопку в цикл 
<p><button onclick="alert('hello')">Добавить в корзину</button></p>

Number 2:
в js файле создаем новую функцию:

function add_to_cart() {
  alert('hello all!');
}
изменяем кнопку :

<p><button onclick="add_to_cart()">Добавить в корзину</button></p>


глюк в js файле и его устранение

javascript file :
  function cart()
{
	alert ('Hello from function');
}        
  html file: 
    		   <div>
				<button class="btn  btn-success "onclick="cart()">Add to cart</button>
			</div>



			браузер выводит данную ошибку Uncaught ReferenceError: cart is not defined(браузер не видит функцию в js файле
в результате чего add_to_cart не инициализируется)
			
      ошибка в результате вывода данного кода


1 стоит создать новый js файл поместить туда нужный код и сделать на него ссылку 

2 написать функцию в html файл использую  тег скрипт


добавление параметра в функцию 
js файл
таким образом каждому обьекту (пицце) будет присвоен уникальный идентификатор
function add_to_cart(id)
{
	alert ('You added pizza with id:'+id);
}

html файл

<div>
				<button class="btn  btn-success "onclick="add_to_cart(<%=p.id%>)">Add to cart</button>
			</div>
 
